/**
 * Artifact Action Protocol
 *
 * Agents embed structured artifact action blocks in their chat responses
 * to upload files (PDFs, videos, etc.) generated by skills (react-pdf, remotion)
 * to Supabase Storage and save metadata to the crm_documents table.
 *
 * Follows the same extraction pattern as crmActions.ts.
 *
 * An agent can include an artifact action in its response like:
 * ```json
 * {"type":"artifact_action","action":"upload_document","payload":{
 *   "file_path":"/path/to/generated/output.pdf",
 *   "title":"Monthly Sales Report",
 *   "doc_type":"pdf",
 *   "tags":["report","sales"],
 *   "project_id":"uuid"
 * }}
 * ```
 */

import { supabase, isSupabaseConfigured } from './supabase';
import { createNotificationDirect } from '../hooks/useNotifications';
import type { DocType } from '../types/documents';

// ─── Action Types ────────────────────────────────────────────────────────────

export type ArtifactActionName = 'upload_document';

export interface ArtifactAction {
  type: 'artifact_action';
  action: ArtifactActionName;
  payload: Record<string, unknown>;
}

export interface ArtifactActionResult {
  action: ArtifactActionName;
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
}

// ─── Typed Payloads ──────────────────────────────────────────────────────────

interface UploadDocumentPayload {
  file_path: string;
  title?: string;
  description?: string;
  doc_type?: DocType;
  mime_type?: string;
  tags?: string[];
  contact_id?: string;
  company_id?: string;
  deal_id?: string;
  project_id?: string;
  quote_id?: string;
  invoice_id?: string;
  owner_agent_id?: string;
}

// ─── Helpers ─────────────────────────────────────────────────────────────────

const MIME_MAP: Record<string, string> = {
  '.pdf': 'application/pdf',
  '.mp4': 'video/mp4',
  '.webm': 'video/webm',
  '.mov': 'video/quicktime',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.mp3': 'audio/mpeg',
  '.wav': 'audio/wav',
};

function guessMimeType(fileName: string): string {
  const ext = fileName.slice(fileName.lastIndexOf('.')).toLowerCase();
  return MIME_MAP[ext] || 'application/octet-stream';
}

function inferDocType(mimeType: string): DocType {
  if (mimeType === 'application/pdf') return 'pdf';
  if (mimeType.startsWith('video/')) return 'video';
  return 'file';
}

const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB

const HOME_DIR = '/Users/peetstander';

/**
 * Security: Validate that a file path is within safe directories.
 * Blocks system paths like /etc/, /var/, /usr/ etc.
 */
function isPathAllowed(filePath: string): boolean {
  if (!filePath.startsWith('/')) return false;
  // Must be within $HOME
  if (!filePath.startsWith(HOME_DIR + '/')) return false;
  // Block dotfiles in home root (e.g. ~/.ssh, ~/.gnupg) except .openclaw
  const relative = filePath.slice(HOME_DIR.length + 1);
  if (relative.startsWith('.') && !relative.startsWith('.openclaw/')) return false;
  return true;
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

function normalizeArtifactAction(value: unknown): ArtifactAction | null {
  if (!isRecord(value)) return null;
  if (value.type !== 'artifact_action') return null;
  if (typeof value.action !== 'string') return null;
  if (!isRecord(value.payload)) return null;

  return {
    type: 'artifact_action',
    action: value.action as ArtifactActionName,
    payload: value.payload,
  };
}

// ─── Extraction ──────────────────────────────────────────────────────────────

const ARTIFACT_ACTION_REGEX = /\{[^{}]*"type"\s*:\s*"artifact_action"[^{}]*\}/g;
const MAX_SCAN_LENGTH = 200_000;

/**
 * Extract artifact action blocks from an agent's chat response text.
 */
export function extractArtifactActions(text: string): ArtifactAction[] {
  if (!text || text.length > MAX_SCAN_LENGTH) return [];
  if (!text.includes('artifact_action')) return [];

  const actions: ArtifactAction[] = [];
  const seen = new Set<string>();

  // Try each regex match
  const matches = text.matchAll(ARTIFACT_ACTION_REGEX);
  for (const match of matches) {
    try {
      const parsed = JSON.parse(match[0]);
      const action = normalizeArtifactAction(parsed);
      if (action) {
        const key = `${action.action}:${JSON.stringify(action.payload)}`;
        if (!seen.has(key)) {
          seen.add(key);
          actions.push(action);
        }
      }
    } catch {
      // Ignore malformed JSON
    }
  }

  // Also try line-by-line for multi-line JSON blocks (e.g. in code fences)
  const lines = text.split(/\r?\n/);
  let buffer = '';
  let depth = 0;

  for (const line of lines) {
    const trimmed = line.trim();
    if (depth === 0 && trimmed.startsWith('{') && trimmed.includes('artifact_action')) {
      buffer = '';
      depth = 0;
    }

    if (depth > 0 || (trimmed.startsWith('{') && trimmed.includes('artifact_action'))) {
      buffer += trimmed;
      for (const ch of trimmed) {
        if (ch === '{') depth++;
        else if (ch === '}') depth--;
      }

      if (depth === 0 && buffer) {
        try {
          const parsed = JSON.parse(buffer);
          const action = normalizeArtifactAction(parsed);
          if (action) {
            const key = `${action.action}:${JSON.stringify(action.payload)}`;
            if (!seen.has(key)) {
              seen.add(key);
              actions.push(action);
            }
          }
        } catch {
          // Ignore
        }
        buffer = '';
      }
    }
  }

  return actions;
}

// ─── Stripping ───────────────────────────────────────────────────────────────

const ARTIFACT_ACTION_JSON_LINE = /^\s*\{[^}]*"type"\s*:\s*"artifact_action"[^]*\}\s*$/;

/**
 * Strip artifact action JSON blocks from displayed chat text.
 * Removes both inline and multi-line blocks.
 */
export function stripArtifactActionBlocks(text: string): string {
  if (!text) return text;
  if (!text.includes('artifact_action')) return text;

  const lines = text.split('\n');
  const kept: string[] = [];
  let depth = 0;
  let inBlock = false;

  for (const line of lines) {
    const trimmed = line.trim();

    // Single-line match
    if (depth === 0 && ARTIFACT_ACTION_JSON_LINE.test(trimmed)) {
      continue;
    }

    // Multi-line block tracking
    if (!inBlock && depth === 0 && trimmed.startsWith('{') && trimmed.includes('artifact_action')) {
      inBlock = true;
      depth = 0;
    }

    if (inBlock) {
      for (const ch of trimmed) {
        if (ch === '{') depth++;
        else if (ch === '}') depth--;
      }
      if (depth <= 0) {
        inBlock = false;
        depth = 0;
      }
      continue;
    }

    kept.push(line);
  }

  return kept.join('\n').replace(/\n{3,}/g, '\n\n').trim();
}

// ─── Execution ───────────────────────────────────────────────────────────────

const STORAGE_BUCKET = 'crm-documents';

/**
 * Execute a single artifact action.
 */
async function executeArtifactAction(
  action: ArtifactAction,
  sourceAgentId: string,
): Promise<ArtifactActionResult> {
  if (!isSupabaseConfigured()) {
    return { action: action.action, success: false, error: 'Supabase not configured' };
  }

  try {
    switch (action.action) {
      case 'upload_document': {
        const p = action.payload as unknown as UploadDocumentPayload;

        if (!p.file_path || typeof p.file_path !== 'string') {
          return { action: 'upload_document', success: false, error: 'Missing file_path' };
        }

        // Security: validate file path
        if (!isPathAllowed(p.file_path)) {
          return {
            action: 'upload_document',
            success: false,
            error: `File path not allowed: ${p.file_path}`,
          };
        }

        // Read binary from disk via Tauri
        const { readFile } = await import('@tauri-apps/plugin-fs');
        let bytes: Uint8Array;
        try {
          bytes = await readFile(p.file_path);
        } catch (err) {
          return {
            action: 'upload_document',
            success: false,
            error: `Failed to read file: ${err instanceof Error ? err.message : String(err)}`,
          };
        }

        // File size check
        if (bytes.length > MAX_FILE_SIZE) {
          return {
            action: 'upload_document',
            success: false,
            error: `File too large (${(bytes.length / 1024 / 1024).toFixed(1)}MB). Maximum is 50MB.`,
          };
        }

        // Construct File object from binary data
        const fileName = p.file_path.split('/').pop() || 'artifact';
        const mimeType = p.mime_type || guessMimeType(fileName);
        const blob = new Blob([new Uint8Array(bytes)], { type: mimeType });
        const file = new File([blob], fileName, { type: mimeType });

        // Upload to Supabase Storage
        const timestamp = Date.now();
        const safeName = fileName.replace(/[^a-zA-Z0-9._-]/g, '_');
        const storagePath = `${timestamp}_${safeName}`;

        const { error: uploadError } = await supabase.storage
          .from(STORAGE_BUCKET)
          .upload(storagePath, file, { cacheControl: '3600', upsert: false });

        if (uploadError) {
          return {
            action: 'upload_document',
            success: false,
            error: `Storage upload failed: ${uploadError.message}`,
          };
        }

        // Insert DB record
        const docType = p.doc_type || inferDocType(mimeType);
        const record = {
          title: p.title || fileName,
          description: p.description || null,
          doc_type: docType,
          storage_path: storagePath,
          file_name: fileName,
          file_size: file.size,
          mime_type: mimeType,
          contact_id: p.contact_id || null,
          company_id: p.company_id || null,
          deal_id: p.deal_id || null,
          project_id: p.project_id || null,
          quote_id: p.quote_id || null,
          invoice_id: p.invoice_id || null,
          owner_agent_id: p.owner_agent_id || sourceAgentId,
          tags: p.tags || [],
        };

        const { data, error: dbError } = await supabase
          .from('crm_documents')
          .insert(record)
          .select()
          .single();

        if (dbError) {
          // Clean up storage on DB failure
          await supabase.storage.from(STORAGE_BUCKET).remove([storagePath]);
          return {
            action: 'upload_document',
            success: false,
            error: `DB insert failed: ${dbError.message}`,
          };
        }

        // Notification
        const typeLabel = mimeType.includes('pdf')
          ? 'a PDF document'
          : mimeType.startsWith('video/')
            ? 'a video'
            : 'a file';

        createNotificationDirect(
          'system',
          `Artifact uploaded: ${p.title || fileName}`,
          `Agent generated and uploaded ${typeLabel}`,
          undefined,
          undefined,
          sourceAgentId,
          'info',
        ).catch(() => {
          // Non-critical — don't fail the action
        });

        console.log(`[Artifact Actions] upload_document succeeded: ${p.title || fileName}`);
        return {
          action: 'upload_document',
          success: true,
          data: data as Record<string, unknown>,
        };
      }

      default:
        return {
          action: action.action,
          success: false,
          error: `Unknown artifact action: ${action.action}`,
        };
    }
  } catch (err) {
    return {
      action: action.action,
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

// ─── Public Processor ────────────────────────────────────────────────────────

/**
 * Process all artifact actions found in an agent response.
 * Returns results for each action executed.
 */
export async function processArtifactActions(
  text: string,
  sourceAgentId: string,
): Promise<ArtifactActionResult[]> {
  const actions = extractArtifactActions(text);
  if (actions.length === 0) return [];

  console.log(
    `[Artifact Actions] Found ${actions.length} action(s):`,
    actions.map((a) => a.action),
  );

  const results: ArtifactActionResult[] = [];
  for (const action of actions) {
    const result = await executeArtifactAction(action, sourceAgentId);
    if (!result.success) {
      console.error(`[Artifact Actions] ${action.action} failed:`, result.error);
    }
    results.push(result);
  }

  return results;
}
